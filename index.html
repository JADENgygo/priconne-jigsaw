<html>
	<head>
		<meta charSet="utf-8" />
		<meta name="description" content="プリコネRのジグソーパズル" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@JADENgygo" />
		<meta property="og:url" content="https://priconne-jigsaw.vercel.app" />
		<meta property="og:title" content="プリコネジグソー" />
		<meta property="og:description" content="プリコネRのジグソーパズル" />
		<meta property="og:image" content="https://priconne-jigsaw.vercel.app/img/peko.png" />
		<meta name="viewport" content="width=device-width" />
		<title>プリコネジグソー</title>
		<link rel="icon" href="img/peko.png" />
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
		<style>
			.content {
			  position: relative;
			  min-height: 100vh;
			  padding: 0 0 150px 0;
			}
			footer {
			  position: absolute;
			  bottom: 0;
			  width: 100%;
			}
		</style>
	</head>
	<body>
    <div id="game"></div>
		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
		<script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
		<script>
      class Title extends Phaser.Scene {
        constructor() {
          super({key: "Title"});
        }
        init() {
        }
        preload() {
          for (let i = 0; i < 100; ++i) {
            this.load.image("piece" + i, "img/piece" + i + ".png");
          }
          this.load.scenePlugin('rexgesturesplugin', 'https://raw.githubusercontent.com/rexrainbow/phaser3-rex-notes/master/dist/rexgesturesplugin.min.js', 'rexGestures', 'rexGestures');
        }
        tap;
        create() {
          this.tap = this.rexGestures.add.tap({tapInterval: 0});

          const canvas = this.sys.game.canvas;
          this.add.rectangle(canvas.width / 2, canvas.height / 2, canvas.width, canvas.height, "0xffffff");

          const title = "プリコネジグソー";
          const fontSize = 30;
          this.add.text((canvas.width - fontSize * title.length) / 2, canvas.height / 10, title, {font: `bold ${fontSize}px sans-serif`, fill: "#000"});

          let id = 0;
          const items = ["美食殿", "トゥインクルウィッシュ", "リトルリリカル", "決定"];
          const c = "〈" + "　".repeat(Math.max(...items.map(e => e.length))) + "〉";
          const cursor = this.add.text((canvas.width - fontSize * c.length) / 2, canvas.height / 10 * 4, c, {font: `${fontSize}px sans-serif`, fill: "#000"});
          this.add.text((canvas.width - fontSize * items[0].length) / 2, canvas.height / 10 * 4, items[0], {font: `${fontSize}px sans-serif`, fill: "#000"}).setInteractive()
          .on("pointerdown", () => {
            cursor.y = canvas.height / 10 * 4;
            id = 0;
          });
          this.add.text((canvas.width - fontSize * items[1].length) / 2, canvas.height / 10 * 5, items[1], {font: `${fontSize}px sans-serif`, fill: "#000"}).setInteractive()
          .on("pointerdown", () => {
            cursor.y = canvas.height / 10 * 5;
            id = 1;
          });
          this.add.text((canvas.width - fontSize * items[2].length) / 2, canvas.height / 10 * 6, items[2], {font: `${fontSize}px sans-serif`, fill: "#000"}).setInteractive()
          .on("pointerdown", () => {
            cursor.y = canvas.height / 10 * 6
            id = 2;
          });
          this.add.text((canvas.width - fontSize * items[3].length) / 2, canvas.height / 10 * 7, items[3], {font: `${fontSize}px sans-serif`, fill: "#000"}).setInteractive()
          .on("pointerdown", () => this.scene.start("Game", {id}));

          this.scene.start("Game", {id});
        }
        update() {
        }
      }
      class Game extends Phaser.Scene {
        constructor() {
          super({key: "Game"});
        }
        id;
        init(data) {
          this.id = data.id;
        }
        preload() {
          const canvas = this.sys.game.canvas;
          this.add.rectangle(canvas.width / 2, canvas.height / 2, canvas.width, canvas.height, "0xffffff");
          for (let i = 0; i < 100; ++i) {
            this.load.image("piece" + i, "img/piece" + i + ".png");
          }
        }
        pieces = [];
        connections = [];
        create() {
          const canvas = this.sys.game.canvas;
          this.add.rectangle(canvas.width / 2, canvas.height / 2, canvas.width, canvas.height, "0xffffff");

          let depth = 0;
          for (let i = 0; i < 100; ++i) {
            const pieceSize = 230;
            const scale = Math.min(canvas.width, canvas.height) / 10 / pieceSize;
            const x = i % 10;
            const y = Math.trunc(i / 10);
            const piece = this.add.image(pieceSize / 2 * scale + pieceSize * scale * x, pieceSize / 2 * scale + pieceSize * scale * y, "piece" + i).setScale(scale);
            // piece.x = Math.trunc(Math.random() * (Math.min(canvas.width, canvas.height) - pieceSize * scale * 2) + pieceSize * scale);
            // piece.y = Math.trunc(Math.random() * (Math.min(canvas.width, canvas.height) - pieceSize * scale * 2) + pieceSize * scale);
            const effectivePieceSize = 192 * scale;
            piece.setInteractive({draggable: true})
            .on("dragstart", (pointer, dragX, dragY) => {
              depth++;
              piece.setDepth(depth);
              this.connections.forEach(el => {
                if (el.includes(i)) {
                  el.forEach(e => this.pieces[e].setDepth(depth));
                }
              });
            })
            .on("drag", (pointer, dragX, dragY) => {
              piece.x = dragX;
              piece.y = dragY;
              this.connections.forEach(el => {
                if (el.includes(i)) {
                  el.forEach(e => {
                    if (e === i) {
                      return;
                    }
                    const xi = i % 10;
                    const yi = Math.trunc(i / 10);
                    const xe = e % 10;
                    const ye = Math.trunc(e / 10);
                    this.pieces[e].x = piece.x + (xe - xi) * effectivePieceSize;
                    this.pieces[e].y = piece.y + (ye - yi) * effectivePieceSize;
                  });
                }
              });
            })
            .on("dragend", () => {
              const connect = (index) => {
                const adjustPosition = (i, offset) => {
                    console.log('first', i, offset)
                  if (this.connections.some(e => e.includes(i) && e.includes(i + offset))) {
                    console.log('return', i, offset)
                    return;
                  }
                  if (this.connections.some(e => e.includes(i)) && this.connections.some(e => e.includes(i + offset))) {
                    const c = this.connections.find(e => e.includes(i)).concat(this.connections.find(e => e.includes(i + offset)));
                    const rests = this.connections.filter(e => !e.includes(i) && !e.includes(i + offset));
                    this.connections = rests.length === 0 ? [c] : rests.concat([c]);
                  }
                  else if (this.connections.some(e => e.includes(i)) && !this.connections.some(e => e.includes(i + offset))) {
                    this.connections = this.connections.map(e => e.includes(i) ? [...e, i + offset] : e);
                  }
                  else if (!this.connections.some(e => e.includes(i)) && this.connections.some(e => e.includes(i + offset))) {
                    this.connections = this.connections.map(e => e.includes(i + offset) ? [...e, i] : e);
                  }
                  else {
                    this.connections.push([i, i + offset]);
                  }
                  switch (offset) {
                    case 1:
                      this.pieces[i].x = this.pieces[i + offset].x - effectivePieceSize;
                      this.pieces[i].y = this.pieces[i + offset].y;
                      break;
                    case -1:
                      this.pieces[i].x = this.pieces[i + offset].x + effectivePieceSize;
                      this.pieces[i].y = this.pieces[i + offset].y;
                      break;
                    case -10:
                      this.pieces[i].x = this.pieces[i + offset].x;
                      this.pieces[i].y = this.pieces[i + offset].y + effectivePieceSize;
                      break;
                    case 10:
                      this.pieces[i].x = this.pieces[i + offset].x;
                      this.pieces[i].y = this.pieces[i + offset].y - effectivePieceSize;
                      break;
                  }
                  this.connections.forEach(el => {
                    if (!el.includes(i)) {
                      return;
                    }
                    el.forEach(e => {
                      if (e === i) {
                        return;
                      }
                      const xi = i % 10;
                      const yi = Math.trunc(i / 10);
                      const xe = e % 10;
                      const ye = Math.trunc(e / 10);
                      this.pieces[e].x = this.pieces[i].x + (xe - xi) * effectivePieceSize;
                      this.pieces[e].y = this.pieces[i].y + (ye - yi) * effectivePieceSize;
                    });
                  });
                };
                const diff = effectivePieceSize;
                const x = index % 10;
                const y = Math.trunc(index / 10);
                if (x !== 9 && this.pieces[index].x < this.pieces[index + 1].x && this.pieces[index + 1].x - this.pieces[index].x < diff && Math.abs(this.pieces[index + 1].y - this.pieces[index].y) < diff) {
                  adjustPosition(index, 1);
                }
                if (x !== 0 && this.pieces[index - 1].x < this.pieces[index].x && this.pieces[index].x - this.pieces[index - 1].x < diff && Math.abs(this.pieces[index].y - this.pieces[index - 1].y) < diff) {
                  adjustPosition(index, -1);
                }
                if (y !== 0 && Math.abs(this.pieces[index].x - this.pieces[index - 10].x) < diff && this.pieces[index - 10].y < this.pieces[index].y && this.pieces[index].y - this.pieces[index - 10].y < diff) {
                  adjustPosition(index, -10);
                }
                if (y !== 9 && Math.abs(this.pieces[index + 10].x - this.pieces[index].x) < diff && this.pieces[index].y < this.pieces[index + 10].y && this.pieces[index + 10].y - this.pieces[index].y < diff) {
                  adjustPosition(index, 10);
                }
              };
              connect(i);
                  console.log(i, this.connections)
              this.connections.forEach(el => {
                if (!el.includes(i)) {
                  console.log('yhere')
                  return;
                }
                el.forEach(e => {
                  if (e === i) {
                    // return;
                  }
                  connect(e);
                });
              });
            });
            this.pieces.push(piece);
          }
        }
        update() {
        }
      }

			const config = {
				parent: "game",
				type: Phaser.AUTO,
        width: "100",
        height: "100",
				physics: {
					default: 'arcade',
					arcade: {
						gravity: { y: 200 }
					}
				},
        scene: [Title, Game]
			};
			const game = new Phaser.Game(config);
		</script>
	</body>
</html>

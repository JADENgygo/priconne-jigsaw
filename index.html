<html>
	<head>
		<meta charSet="utf-8" />
		<meta name="description" content="プリコネRのジグソーパズル" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@JADENgygo" />
		<meta property="og:url" content="https://priconne-jigsaw.vercel.app" />
		<meta property="og:title" content="プリコネジグソー" />
		<meta property="og:description" content="プリコネRのジグソーパズル" />
		<meta property="og:image" content="https://priconne-jigsaw.vercel.app/img/peko.png" />
		<meta name="viewport" content="width=device-width" />
		<title>プリコネジグソー</title>
		<link rel="icon" href="img/peko.png" />
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
		<style>
			.content {
			  position: relative;
			  min-height: 100vh;
			  padding: 0 0 150px 0;
			}
			footer {
			  position: absolute;
			  bottom: 0;
			  width: 100%;
			}
		</style>
	</head>
	<body>
    <div id="game"></div>
		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
		<script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
		<script>
      class Title extends Phaser.Scene {
        constructor() {
          super({key: "Title"});
        }
        init() {
        }
        preload() {
          this.load.image("original0", "img/original0.png");
          this.load.image("original1", "img/original1.png");
          this.load.image("original2", "img/original2.png");
        }
        create() {
          const canvas = this.sys.game.canvas;
          const originalSize = 1920;
          const scale = Math.min(canvas.width, canvas.height) / originalSize;
          const effectiveSize = originalSize * scale;
          const original0 = this.add.image(effectiveSize / 2 + (canvas.width - effectiveSize) / 2, effectiveSize / 2 + (canvas.height - effectiveSize) / 2, "original0").setScale(scale);
          const original1 = this.add.image(effectiveSize / 2 + (canvas.width - effectiveSize) / 2, effectiveSize / 2 + (canvas.height - effectiveSize) / 2, "original1").setScale(scale).setVisible(false);
          const original2 = this.add.image(effectiveSize / 2 + (canvas.width - effectiveSize) / 2, effectiveSize / 2 + (canvas.height - effectiveSize) / 2, "original2").setScale(scale).setVisible(false);

          const t = "プリコネジグソー";
          const fontSize = 30;
          const title = this.add.text((canvas.width - fontSize * t.length) / 2, canvas.height / 10 * 3 - fontSize / 2, t, {font: `bold ${fontSize}px sans-serif`, fill: "#000"}).setDepth(1);

          let id = 0;
          const items = ["美食殿", "カルミナ", "リトルリリカル", "決定"];
          const c = "〈" + "　".repeat(Math.max(...items.map(e => e.length))) + "〉";
          const cursor = this.add.text((canvas.width - fontSize * c.length) / 2, canvas.height / 10 * 4 - fontSize / 2, c, {font: `${fontSize}px sans-serif`, fill: "#000"}).setDepth(1);
          const item0 = this.add.text((canvas.width - fontSize * items[0].length) / 2, canvas.height / 10 * 4 - fontSize / 2, items[0], {font: `${fontSize}px sans-serif`, fill: "#000"}).setDepth(1).setInteractive()
          .on("pointerdown", () => {
            cursor.y = item0.y;
            id = 0;
            original0.setVisible(true);
            original1.setVisible(false);
            original2.setVisible(false);
          });
          const item1 = this.add.text((canvas.width - fontSize * items[1].length) / 2, canvas.height / 10 * 5 - fontSize / 2, items[1], {font: `${fontSize}px sans-serif`, fill: "#000"}).setDepth(1).setInteractive()
          .on("pointerdown", () => {
            cursor.y = item1.y;
            id = 1;
            original0.setVisible(false);
            original1.setVisible(true);
            original2.setVisible(false);
          });
          const item2 = this.add.text((canvas.width - fontSize * items[2].length) / 2, canvas.height / 10 * 6 - fontSize / 2, items[2], {font: `${fontSize}px sans-serif`, fill: "#000"}).setDepth(1).setInteractive()
          .on("pointerdown", () => {
            cursor.y = item2.y;
            id = 2;
            original0.setVisible(false);
            original1.setVisible(false);
            original2.setVisible(true);
          });
          this.add.text((canvas.width - fontSize * items[3].length) / 2, canvas.height / 10 * 7 - fontSize / 2, items[3], {font: `${fontSize}px sans-serif`, fill: "#000"}).setDepth(1).setInteractive()
          .on("pointerdown", () => {
            this.scene.start("Game", {id})
          });

          this.add.graphics().fillStyle(0xffffff, 0.75).fillRoundedRect(title.x - fontSize, canvas.height / 10 * 2, t.length * fontSize + fontSize * 2, canvas.height / 10 * 6, 32);

          // this.scene.start("Game", {id});
        }
        update() {
        }
      }
      class Game extends Phaser.Scene {
        constructor() {
          super({key: "Game"});
        }
        id;
        loader;
        init(data) {
          const canvas = this.sys.game.canvas;
          const t = "ロード中";
          const fontSize = 20;
          this.loader = this.add.text((canvas.width - t.length * fontSize) / 2, canvas.height / 2, t, {font: `${fontSize}px sans-serif`, fill: "#000"}).setDepth(10);
          this.id = data.id;
        }
        preload() {
          console.log(this.id)
          const canvas = this.sys.game.canvas;
          this.add.rectangle(canvas.width / 2, canvas.height / 2, canvas.width, canvas.height, "0xffffff");
          for (let i = 0; i < 100; ++i) {
            this.load.image("piece" + i, `img/piece_${this.id}_${i}.png`);
            this.load.image("shadow" + i, `img/piece_${this.id}_${i}.png`);
          }
        }
        pieces = [];
        connections = [];
        create() {
          const canvas = this.sys.game.canvas;
          this.add.rectangle(canvas.width / 2, canvas.height / 2, canvas.width, canvas.height, "0xffffff");

          for (let i = 0; i < 100; ++i) {
            const pieceSize = 230;
            const scale = Math.min(canvas.width, canvas.height) / 10 / pieceSize;
            const x = i % 10;
            const y = Math.trunc(i / 10);
            const piece = this.add.image(pieceSize / 2 * scale + pieceSize * scale * x, pieceSize / 2 * scale + pieceSize * scale * y, "piece" + i).setScale(scale);
            // piece.x = Math.trunc(Math.random() * (Math.min(canvas.width, canvas.height) - pieceSize * scale * 3) + pieceSize * scale * 1.5);
            // piece.y = Math.trunc(Math.random() * (Math.min(canvas.width, canvas.height) - pieceSize * scale * 3) + pieceSize * scale * 1.5);
            const effectivePieceSize = 192 * scale;
            let shadow = {};
            const shadowOffset = effectivePieceSize / 10;
            const shadowAlpha = 0.5;
            piece.setInteractive({draggable: true})
            .on("dragstart", (pointer, dragX, dragY) => {
              piece.setDepth(2);
              shadow = {};
              const s = this.add.image(piece.x + shadowOffset, piece.y + shadowOffset, "shadow" + i).setTint(0x000).setAlpha(shadowAlpha).setScale(scale).setDepth(1);
              shadow[i] = s;
              this.connections.forEach(el => {
                if (el.includes(i)) {
                  el.forEach(e => {
                    if (e === i) {
                      return;
                    }
                    this.pieces[e].setDepth(2);
                    const s = this.add.image(this.pieces[e].x + shadowOffset, this.pieces[e].y + shadowOffset, "shadow" + e).setTint(0x000).setAlpha(shadowAlpha).setScale(scale).setDepth(1);
                    shadow[e] = s;
                });
                }
              });
            })
            .on("drag", (pointer, dragX, dragY) => {
              piece.x = dragX;
              piece.y = dragY;
              shadow[i].x = dragX + shadowOffset;
              shadow[i].y = dragY + shadowOffset;
              this.connections.forEach(el => {
                if (el.includes(i)) {
                  el.forEach(e => {
                    if (e === i) {
                      return;
                    }
                    const xi = i % 10;
                    const yi = Math.trunc(i / 10);
                    const xe = e % 10;
                    const ye = Math.trunc(e / 10);
                    this.pieces[e].x = piece.x + (xe - xi) * effectivePieceSize;
                    this.pieces[e].y = piece.y + (ye - yi) * effectivePieceSize;
                    shadow[e].x = this.pieces[e].x + shadowOffset;
                    shadow[e].y = this.pieces[e].y + shadowOffset;
                  });
                }
              });
            })
            .on("dragend", () => {
              const connect = (index) => {
                const adjustPosition = (i, offset) => {
                  if (this.connections.some(e => e.includes(i) && e.includes(i + offset))) {
                    return;
                  }
                  if (this.connections.some(e => e.includes(i)) && this.connections.some(e => e.includes(i + offset))) {
                    const c = this.connections.find(e => e.includes(i)).concat(this.connections.find(e => e.includes(i + offset)));
                    const rests = this.connections.filter(e => !e.includes(i) && !e.includes(i + offset));
                    this.connections = rests.length === 0 ? [c] : rests.concat([c]);
                  }
                  else if (this.connections.some(e => e.includes(i)) && !this.connections.some(e => e.includes(i + offset))) {
                    this.connections = this.connections.map(e => e.includes(i) ? [...e, i + offset] : e);
                  }
                  else if (!this.connections.some(e => e.includes(i)) && this.connections.some(e => e.includes(i + offset))) {
                    this.connections = this.connections.map(e => e.includes(i + offset) ? [...e, i] : e);
                  }
                  else {
                    this.connections.push([i, i + offset]);
                  }
                  switch (offset) {
                    case 1:
                      this.pieces[i].x = this.pieces[i + offset].x - effectivePieceSize;
                      this.pieces[i].y = this.pieces[i + offset].y;
                      break;
                    case -1:
                      this.pieces[i].x = this.pieces[i + offset].x + effectivePieceSize;
                      this.pieces[i].y = this.pieces[i + offset].y;
                      break;
                    case -10:
                      this.pieces[i].x = this.pieces[i + offset].x;
                      this.pieces[i].y = this.pieces[i + offset].y + effectivePieceSize;
                      break;
                    case 10:
                      this.pieces[i].x = this.pieces[i + offset].x;
                      this.pieces[i].y = this.pieces[i + offset].y - effectivePieceSize;
                      break;
                  }
                  this.connections.forEach(el => {
                    if (!el.includes(i)) {
                      return;
                    }
                    el.forEach(e => {
                      if (e === i) {
                        return;
                      }
                      const xi = i % 10;
                      const yi = Math.trunc(i / 10);
                      const xe = e % 10;
                      const ye = Math.trunc(e / 10);
                      this.pieces[e].x = this.pieces[i].x + (xe - xi) * effectivePieceSize;
                      this.pieces[e].y = this.pieces[i].y + (ye - yi) * effectivePieceSize;
                    });
                  });
                };
                const diff = effectivePieceSize;
                const x = index % 10;
                const y = Math.trunc(index / 10);
                if (x !== 9 && this.pieces[index].x < this.pieces[index + 1].x && this.pieces[index + 1].x - this.pieces[index].x < diff && Math.abs(this.pieces[index + 1].y - this.pieces[index].y) < diff) {
                  adjustPosition(index, 1);
                }
                if (x !== 0 && this.pieces[index - 1].x < this.pieces[index].x && this.pieces[index].x - this.pieces[index - 1].x < diff && Math.abs(this.pieces[index].y - this.pieces[index - 1].y) < diff) {
                  adjustPosition(index, -1);
                }
                if (y !== 0 && Math.abs(this.pieces[index].x - this.pieces[index - 10].x) < diff && this.pieces[index - 10].y < this.pieces[index].y && this.pieces[index].y - this.pieces[index - 10].y < diff) {
                  adjustPosition(index, -10);
                }
                if (y !== 9 && Math.abs(this.pieces[index + 10].x - this.pieces[index].x) < diff && this.pieces[index].y < this.pieces[index + 10].y && this.pieces[index + 10].y - this.pieces[index].y < diff) {
                  adjustPosition(index, 10);
                }
              };
              connect(i);
              piece.setDepth(0);
              this.connections.forEach(el => {
                if (!el.includes(i)) {
                  return;
                }
                el.forEach(e => {
                  if (e === i) {
                    return;
                  }
                  connect(e);
                  this.pieces[e].setDepth(0);
                });
              });
              Object.keys(shadow).map(key => shadow[key].destroy());
            });
            this.pieces.push(piece);
          }
          const fontSize = 15;
          const b = "パズル選択に戻る　　";
          const back = this.add.text(canvas.width / 10, fontSize, b, {font: `${fontSize}px sans-serif`, fill: "#000"}).setDepth(10);
          back.setInteractive().on("pointerdown", () => {
            for (let i = 0; i < 100; ++i) {
              this.textures.remove("piece" + i);
              this.textures.remove("shadow" + i);
            }
            this.scene.start("Title");
          });
          const s = "セーブ　　"
          const save = this.add.text(back.x + b.length * fontSize, fontSize, s, {font: `${fontSize}px sans-serif`, fill: "#000"}).setDepth(10);
          save.setInteractive().on("pointerdown", () => {
            const storage = localStorage;
            for (let i = 0; i < 100; ++i) {
              storage.setItem(`piece_${this.id}_${i}_x`, this.pieces[i].x);
              storage.setItem(`piece_${this.id}_${i}_y`, this.pieces[i].y);
            }
            storage.setItem(`connection_${this.id}`, this.connections.map(e => "[" + e.toString() + "]").join(","));
          });
          const l = "ロード";
          this.add.text(save.x + s.length * fontSize, fontSize, l, {font: `${fontSize}px sans-serif`, fill: "#000"}).setDepth(10);
          this.loader.setVisible(false);
        }
        update() {
        }
      }

			const config = {
				parent: "game",
				type: Phaser.AUTO,
        width: "100",
        height: "100",
				physics: {
					default: 'arcade',
					arcade: {
						gravity: { y: 200 }
					}
				},
        scene: [Title, Game]
			};
			const game = new Phaser.Game(config);
		</script>
	</body>
</html>
